# 42seoul_cube3d


42서울 과제 중 cube_3d라는 과제가 있다...

 

cube_3d과제를 수행하면서 필요한 지식들을 여기에 정리해볼까 한다.(내가 정리가 필요하다...)

 

cube_3d과제는 원시적인 3d게임을 구현하는 과제다.

유명한 fps게임을 예를 들면 서든어택을 예로 들 수 있으며 여기서 쓰이는 기술은 "레이캐스팅"이라는 기술을 사용한다.


Wolfenstein 3D
 


서든어택 
레이캐스팅이란 ray(광선), casting(던지다) 즉, 현재 위치에서 광선을 던져? 쏴서 벽(또는 장애물)이 충돌하는 지점을 찾아 거리를 구하는 기술이다.  서든 어택 같은 fps게임을 보면 총알을 쏜다. 총알 또한 레이캐스팅 기술로 구현한 것이다.

 

정리하면,

 

<레이캐스팅 - raycasting>
레이캐스팅은 2차원 맵에서 3차원의 원근감을 만드는 렌더링 기술이다.

(렌더링 기술 : 컴퓨터 프로그램을 사용하여 모델 또는 이들을 모아놓은 장면인 씬 파일로부터 영상을 만들어내는 과정.. 한번 검색해보기를)

 

- 레이캐스팅은 전면 스크린에 모든 수직선에 대해 계산(calculation)만 하면 되어서 속도가 빠릅니다.

- 컴퓨터가 지금보다 느려서 3D 엔진을 실시간으로 실행 할 수 없었던 과거에는 레이캐스팅 기술이 최초의 해결책 이었으며,  가장 근본적인 비디오 그래픽 응용 수단이 되었습니다.

 

솔직히 레이캐스팅은 나온지 오래 되었을 뿐만아니라 실질적으로 좀 더 현실처럼 그래픽처리를 하려면 "레이트레이싱"이라는 기술이 있습니다만... 이 글에서는 레이캐스팅만 다루도록 하겠습니다.(cube_3d에 필요한 내용만 정리하고 레이트레이싱은 다음에 다루도록 하겠습니다.)


레이캐스팅을 이용한 입체영상 구현
 다음 글에서 레이캐스팅의 기본 원리에 대해서 알아보도록 하겠습니다.




---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<레이캐스팅 원리>
2차원 정사각형 그리드로 된 맵이 있습니다.(그리드란 정사각형으로 이루어진 map을 의미합니다. 그림참조)



레이캐스팅을 이용한 map은 기본적인 2D 직사각형 격자 배열(눕히면 위와 같은 그리드 맵)이고 배열의 각 사각형은 0(= 벽이 아닌경우) 또는 0이외의 값(= 벽, 색깔, 장애물 등 외 다른 번호 지정 가능)일 수 있습니다. 

맵을 설명하기 위한 2차원 배열
위와 같이 1과 0으로 이루어진 맵을 상상해보면 1인 곳은 벽, 0인 곳은 사람이 다닐 수 있는 길로 생각하면 된다.



즉, 정리하면 게임에서는 3차원으로 보이지만 2차원으로 이루어진 배열이다.


화면의 가로줄을 x축, 세로줄을 y축인 좌표평면으로 생각하자.
연두점(player), 빨간줄(광선), 파란색 사각형(벽)이라고 정의한다.
광선은 player가 바라보는 방향으로 범위가 바뀝니다.
화면의 모든 x값에 대해 연두점 위치에서부터 시작하는 광선을 쏩니다.
이 광선은 2D맵 위에서 벽에 부딪힐 때까지 직진하다가, 벽에 부딪히면 부딪힌 지점에서부터 player까지의 거리를 계산합니다.
이 거리에 따라서 벽의 높이를 어떻게 보이게 할지를 결정 짖게 되는데, 벽의 높이는 player와 벽 사이의 거리가 멀수록 화면에 더 작게,  가까울 수록 더 크게 보이도록 표시됩니다.
이것들을 모두 2차원으로 배열을 통해 구현할 수 있습니다.




광선이 벽에 처음으로 부딪히면 벽을 찾으려면, 광선을 플레이어의 위치에서부터 출발시켜 광선이 벽에 부딪히는지(포함되는지) 반복적으로 검사 해야합니다.(광선이 벽에 부딪히는 지점을 찾는 것)

광선이 벽에 hit(부딪으는 것)으로 확인되면, 벽에 부딪혔는지 확인하던 함수 loop는 멈추고, 거리를 측적해서 알맞는 높이의 벽이든 장애물을 표현해주면 됩니다.
반대로 벽에 (hit)부딪히지 않는 것으로 확인되면, 계속해서 벽에 부딪혔는 확인하는 함수를 통해서 추적하고, 광선 방향에 맞는 새로운 위치에서 벽에 포함되는지 다시 검사한다. 벽에 부디힐 때까지 계속해서 반복합니다.
광선이 어디서 벽에 부딪히는지 한눈에 알 수 있는 사람과 다르게, 컴퓨터는 광선의 경로 상에 있는 한전된 지점들만 검사 할 수 있기 때문에 공식하나로 그 수치값을 한눈에 확인할 수가 없다.



-----------------------------------------------------------------------------------------------------------------------------------




레이캐스터의 광선은 녹색점에서부터 일정한 값을 반복해서 더해주며 일정한 위치에서 벽에 부딪혔는지 검사한다.

(여기서 부딪혔다는 뜻은 파란영역에 빨간점이 포함되었는지 여부를 뜻함)



위 그림에 의하면 일정한 값을 더했지만 파란벽에 부딪히지 못했다.
이렇게 되면 육안상으로는 광선이 벽에 부딪힌게 틀림 없지만 벽에 부딪히지 않았다고 판단한다.
광선은 파란벽을 통과하여 직진했지만, 컴퓨터는 빨간색 점이 있는 위치에서만 부딪혔다고 판단하기 때문에 감지하지 못한다.
더 많은 위치를 확인하면(즉, 일정 값(파라미터 값)을) 컴퓨터가 놓칠 가능성이 줄어든다. 하지만 더 많은 계산이 필요하다.


-----------------------------------------------------------------------------------------------------------------------------------


검사지점의 간격을 반으로 줄여서 광선이 벽을 통과했음을 확인할 수 있습니다. 그래도 위치가 정확하지 않다는 문제가 있습니다.



이 방법(광선의 위치에 일정한 값을 더해주며 반복하는 방법)을 사용하면서 무한한 정밀도(infinite precision)을 얻기 위해서는, 검사지점 간격이 무한히 작아져야 하고 간격이 무한히 작아지면 수의 계산이 필요하게 됩니다.






효율을 따지자면 정확하게 광선이 파란벽에 딱 맞아떨어지게 해야합니다.

 많은 계산을 하지 않아도 모든 벽을 감지하는 더 좋은 방법은 벽면의 위치 값을 계산하는 것이다.



즉, 벽의 넓이를 1이라고 설정하면 정사각형임으로 가로 세로 1이 되고, 벽의 각 위치 좌표를 알 수 있으며,  광선이 닿는 위치값을 정확하게 파악할 수 있다.



cube_3d를 수행하는 경우 DDA알고리즘(Digital Differential Analysis)이라는 것을 참고하게 된다.DDA알고리즘은 2차원 그리드를 지나가는 선(line)이 어떤 네모칸과 부딪히는지 찾을 수 있는 속도가 빠른 알고리즘 입니다. 이 알고리즘을 사용해서 광선이 맵에서 어떤 네모칸이랑 부딪히는지 알 수 있고, 벽에 부딪힌 것이 확인되면 이 알고리즘은 정답을 찾고 하나의 좌표값을 리턴합니다.
여기까지는 광선이 벽을 찾는데 까지 과정과 방법을 알아보았으며,



이제는 플레이어의 시야를 결정하는 방법을 알아보겠습니다.
















 
